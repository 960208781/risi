//--------------------------------------------------------------
// FingerGestures -- http://fingergestures.fatalfrog.com
// Copyright (c) Fatal Frog Software. All rights reserved
//--------------------------------------------------------------

using System;
using UnityEngine;

namespace HutongGames.PlayMaker.Actions
{
    [ActionCategory("FingerGestures")]
    public abstract class FingerGesturesEvents : FsmStateAction
    {
        [ActionSection("Common Settings")]

        [Tooltip("Set where the events should be sent.")]
        public FsmEventTarget eventTarget;

        [Tooltip("Only respond to events generated by finger with specific index (when applicable)")]
        public FsmInt fingerIndexFilter;

        [Tooltip("Filter by event name")]
        public FsmString eventNameFilter;

        [Tooltip("Specify an optional scene object that the finger/gesture event must start on")]
        public FsmOwnerDefault startObjectFilter;

        [Tooltip("Specify an optional scene object that the finger/gesture event must currently be on")]
        public FsmOwnerDefault currentObjectFilter;

        [ActionSection("Common Outputs")]

        [UIHint(UIHint.Variable)]
        [Tooltip("Variable in which to store the index of finger that generated the last input event (when applicable)")]
        public FsmInt storeFingerIndex;

        [UIHint(UIHint.Variable)]
        [Tooltip("Variable in which to store the object touched by the finger")]
        public FsmGameObject storeCurrentObject;

        [UIHint(UIHint.Variable)]
        [Tooltip("Variable in which to store the object touched by the finger when the event/gesture began")]
        public FsmGameObject storeStartObject;

        public override void Reset()
        {
            startObjectFilter = null;
            currentObjectFilter = null;
            fingerIndexFilter = null;
            eventTarget = null;
            storeFingerIndex = null;
            storeCurrentObject = null;
            storeStartObject = null;
            eventNameFilter = null;
        }

        public override void OnEnter()
        {
            FingerGestures.OnGestureEvent += FingerGestures_OnGestureEvent;
            FingerGestures.OnFingerEvent += FingerGestures_OnFingerEvent;
        }

        public override void OnExit()
        {
            FingerGestures.OnGestureEvent -= FingerGestures_OnGestureEvent;
            FingerGestures.OnFingerEvent -= FingerGestures_OnFingerEvent;
        }

        void FingerGestures_OnFingerEvent(FingerEvent eventData)
        {
            if (!IsValidEventName(eventData.Name))
                return;

            if (!IsValidFinger(eventData.Finger.Index))
                return;

            if (!IsValidObject(startObjectFilter, eventData.Selection) || !IsValidObject(currentObjectFilter, eventData.Selection))
                return;

            if (HandleFingerEvent(eventData))
            {
                storeFingerIndex.Value = eventData.Finger.Index;
                storeCurrentObject.Value = eventData.Selection;
                storeStartObject.Value = eventData.Selection;
            }
        }

        bool IsValidEventName(string eventName)
        {
            if (!string.IsNullOrEmpty(eventNameFilter.Value) && eventNameFilter.Value != eventName)
            {
                Debug.LogWarning("Invalid Event name: " + eventName);
                return false;
            }

            return true;
        }

        protected void FingerGestures_OnGestureEvent(Gesture gesture)
        {
            if (!IsValidEventName(gesture.Recognizer.EventMessageName))
                return;

            if (!IsValidFinger(gesture.Fingers[0].Index))
                return;

            if (!IsValidObject(startObjectFilter, gesture.StartSelection))
            {
                //Debug.Log( gesture.Recognizer.GetType().Name + " " + gesture.StartSelection + " failed startObjectfilter: " + Fsm.GetOwnerDefaultTarget( startObjectFilter ) );
                return;
            }

            if (!IsValidObject(currentObjectFilter, gesture.Selection))
            {
                // Debug.Log(gesture.Recognizer.GetType().Name + " " + gesture.Selection + " failed currentObjectfilter");
                return;
            }

            if (HandleGestureEvent(gesture))
            {
                storeFingerIndex.Value = gesture.Fingers[0].Index;
                storeCurrentObject.Value = gesture.Selection;
                storeStartObject.Value = gesture.StartSelection;
            }
        }

        protected virtual bool HandleFingerEvent(FingerEvent e)
        {
            return true;
        }

        protected virtual bool HandleGestureEvent(Gesture gesture)
        {
            return true;
        }

        #region Utils

        bool IsValidFinger(int fingerIndex)
        {
            if (!fingerIndexFilter.IsNone && fingerIndexFilter.Value != fingerIndex)
                return false;

            return true;
        }

        bool IsValidObject(FsmOwnerDefault filter, GameObject target)
        {
            GameObject go = Fsm.GetOwnerDefaultTarget(filter);
            return !go || (go == target);
        }

        protected void SendEvent(FsmEvent ev)
        {
            if (ev != null)
                Fsm.Event(eventTarget, ev);
        }

        #endregion
    }
}